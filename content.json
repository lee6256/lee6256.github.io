{"meta":{"title":"Leeleg","subtitle":"来自地球的开发者","description":"正努力着向高质量发展","author":"Leeleg","url":"http://yoursite.com"},"pages":[{"title":"Categories","date":"2017-12-02T10:48:13.000Z","updated":"2018-07-21T08:10:40.625Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-01-28T12:55:31.000Z","updated":"2018-07-21T08:10:35.970Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ArrayList的实现原理","slug":"ArrayList的实现原理","date":"2018-08-02T14:56:43.000Z","updated":"2018-08-02T15:00:19.307Z","comments":true,"path":"2018/08/02/ArrayList的实现原理/","link":"","permalink":"http://yoursite.com/2018/08/02/ArrayList的实现原理/","excerpt":"","text":"又是写在开篇的话&emsp;&emsp;我们使用集合类往往都是调用它们的增、删、改、查这些方法，所以我想先从这四个方面去了解集合类。当然，我们还得结合一些总结去看代码，去知其所以然。那次，与总结的第一邂逅 开始旅途的第一步&emsp;&emsp;在Android中，为何展示数据的Adapter多数都是使用ArrayList？根据之前总结的特性，ArrayList的随机查找和修改是高效的，删除和插入则相反，这里肯定有猫腻。当然，不能忘记之前的并发冲突的问题。&emsp;&emsp;ArrayList在进行add、remove和clear时，内部一个记录这些修改元素的操作值会发生改变。 成员变量12345private static final int DEFAULT_CAPACITY = 10; // 使用默认构造方法创建数组时的大小private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125; // 标识 elementData 创建时长度为 0private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; // 标识 elementData 使用默认构造方法创建transient Object[] elementData; // 内部数据结构private int size; // 记录元素个数 在remove或add的时候会改变size。注意，数组长度与元素个数不是相等的。 构造方法三个构造方法都比较简单，但要关注elementData是怎么被初始化的。值得注意的是第三个构造方法，以实现了Collection接口的集合类，来初始化elementData，先通过调用toArray转换成数组，再调用Array.copyOf把传进来的集合复制给elementData。1234567891011121314151617181920212223242526// 默认初始化一个空数组public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;// 由参数控制初始化数组的大小public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; // 此处初始化数组 this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; // 创建一个标识为长度是 0 的空数组 this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; // 参数错误，抛出错误 throw new IllegalArgumentException(\"Illegal Capacity: \" + initialCapacity); &#125;&#125;// public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 值得注意的几个方法，都是经常出现的。而第三个方法就是导致ArrayList插入、删除效率低的原因。123456789101112131415161718192021// ArrayList.java 不同的集合有不同的toArray实现public Object[] toArray() &#123; return Arrays.copyOf(elementData, size);&#125;// Arrays.javapublic static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings(\"unchecked\") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125;// System.java // srcPos 和 destPos 都分别表示 src 和 dest 数组想复制的起点，length表示复制的个数public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 增ArrayList是一个可以自动扩容的1234567891011121314151617181920212223242526272829303132333435363738public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // 扩容检查 elementData[size++] = e; // 数组末尾添加元素 return true;&#125;public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125;public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // 扩容检查 System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0;&#125;public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); // 检查是否越界 Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // 扩容检查 int numMoved = size - index; // 原来数组 index 后的元素个数 = 原来的元素个数 - index if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125; 以下为扩充方法。注意，ArrayList扩容是有上限的，数组最大长度为Integer.MAX_VALUE。1234567891011121314151617181920212223private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 是否为默认构造方法创建的空数组 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); // &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 增加数组的操作次数，AbstractList的成员变量 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 默认扩容一半 if (newCapacity - minCapacity &lt; 0) // 扩容后的大小不足以容纳所有的元素，则使用最小的能容纳所有元素的值 newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) // 扩容后超过数组所能容纳的阈值，则使用最小的能容纳所有元素的值 newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; addAll都是使用 System.arraycopy 完成元素添加，而grow方法使用 Arrays.copyOf 完成数组扩容迁移。 删12345678910111213141516171819202122232425262728293031public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 改改和查都是直接通过下标直接访问，时间复杂度为O(1)，所以ArrayList的随机访问是高效率的。1234567891011public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125;E elementData(int index) &#123; return (E) elementData[index];&#125; 查12345public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125; Android为何高频使用ArrayList有了点眉目Android在loading新的数据往往会在List的尾部添加，而ArrayList往尾部添加新数据时不需要成批复制数组；需要与某个Item互动时，随机访问的时间复杂度是O(1)；很多时候，都只是展示数据，或是更改某个Item。如果有比较多删除Item的业务，那么你需要分析自己的功能，对不同的数据结构进行一个权衡，这样，有助于提升APP的性能。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"一些Java集合类的总结","slug":"一些Java集合类的总结","date":"2018-07-22T13:05:31.000Z","updated":"2018-08-02T15:20:44.962Z","comments":true,"path":"2018/07/22/一些Java集合类的总结/","link":"","permalink":"http://yoursite.com/2018/07/22/一些Java集合类的总结/","excerpt":"","text":"写在开头的话我并不打算一开始就把所有的Java类都拉出来看一遍，毕竟常用的就那么几个，而且它们之间的一些实现原理是相通的，只是根据不同的情况做了改变。因此，我打算从一些基础的Java集合类开始看起，但在此之前先把它们的某些特性了解清楚，如：是否线程安全；内部的数据结构是怎样的。因为知其然，后知所以然，从顶层俯视底层，这样看代码会保有一种清晰的逻辑结构。在这里不会细说实现，只做概括。 主角们各自的归属 首先，从接口中知道它们都有什么样的功能，以下是各种接口的简单介绍： List： 定义了List系的数据操作Map： 定义了Map系的数据操作Serializable： 对象可序列化Cloneable： 对象可拷贝，重写clone方法必须实现此接口Collection： 其实这个接口也继承了Iterable接口，可以使用Iterator迭代元素。RandomAccess： 标志该集合类应当使用哪种遍历算法提高效率 table th:nth-of-type(1) { width: 100px; } table th:nth-of-type(2) { width: 90px; } table th:nth-of-type(3) { width: 120px; } 各自的个性 集合 线程安全性 内部数据结构 效率 备注 ArrayList 不安全 数组 访问快，插入、删除慢 - LinkedList 不安全 双向循环链表 修改、查找慢，插入、删除快 - HashMap 不安全 数组+单链表+红黑树 一般情况下增删改查都是高效率，内部结构变复杂后效率下降 HashMap会根据需要改变内部数据结构 LinkedHashMap 不安全 数组+双向链表 - 可实现LRU算法 HashTable 安全 数组+单链表+红黑树 同HashMap 同HashMap ConcurrentHashMap 安全 数组+双向链表+红黑树 同HashMap 同HashMap CopyOnWriteArrayList 安全 数组 读操作效率高，写操作效率低 会有内存占用和数据一致性问题 从上面的内部数据结构中可以发现一些问题，List系要么只有数组，要么只有链表；而Map都是数组+链表，甚至还有红黑树。其实，Map系是因为要解决相同元素冲突产生碰撞，而采用这种设计，也就是散列表。单向链表和双向链表的区别是，双向链表可以做到顺序存储。红黑树的引入是在JDK8之后添加的，目的是当Map系集合类的元素碰撞过多时，把过长的链表转换为红黑树以提高访问效率。 接下来的就是充满挑战的源码之旅了，希望自己能够坚持下去，然后当作日记去记录下来。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"从ConcurrentModificationException了解Java集合类的一些实现","slug":"从ConcurrentModificationException了解Java集合类的一些实现","date":"2018-07-21T15:07:25.000Z","updated":"2018-07-22T13:10:21.848Z","comments":true,"path":"2018/07/21/从ConcurrentModificationException了解Java集合类的一些实现/","link":"","permalink":"http://yoursite.com/2018/07/21/从ConcurrentModificationException了解Java集合类的一些实现/","excerpt":"","text":"ConcurrentModificationException的出现ConcurrentModificationException，也就是并发修改异常，当我们使用一些Java集合类时，有时需要遍历集合并根据条件remove其中的元素，此时就有可能出现该异常。我们看个简单的例子，注意 list.remove(bean) 这一行：123456789101112131415161718192021222324252627import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class ConcurrentModifyExceptionDemo &#123; public static void main(String[] args) &#123; List&lt;Bean&gt; list = new ArrayList&lt;&gt;(); list.add(new Bean(0)); list.add(new Bean(1)); list.add(new Bean(2)); list.add(new Bean(3)); list.add(new Bean(4)); for (Bean bean : list) &#123; System.out.println(bean.value); if (bean.value == 2) list.remove(bean); &#125; &#125; static class Bean &#123; int value; public Bean(int value) &#123; this.value = value; &#125; &#125;&#125; 从上面的输出信息我们可以看到，在程序输出“3”之前出现了ConcurrentModificationException，也就是说，该异常是在遍历下一个元素时抛出的。总的来说，删除和遍历产生了冲突。如果改变删除的元素为倒数第二个，就是 bean.value = 3 时：12345for (Bean bean : list) &#123; System.out.println(bean.value); if (bean.value == 3) list.remove(bean);&#125; 程序没有抛出ConcurrentModificationException，但是在打印“4”之前程序就结束了，这是为什么呢？ 从ArrayList内部看异常出现的原因ArrayList的遍历在例子中使用了foreach去遍历元素，实际上，foreach遍历的原理就是使用Iterator进行迭代，可以通过javap进行反编译即可查看到相关的字节码指令（看84行的注释）：12345678910... ...74: invokespecial #5 // Method ConcurrentModifyExceptionDemo$Bean.&quot;&lt;init&gt;&quot;:(I)V77: invokeinterface #6, 2 // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z82: pop83: aload_184: invokeinterface #7, 1 // InterfaceMethod java/util/List.iterator:()Ljava/util/Iterator;89: astore_290: aload_291: invokeinterface #8, 1 // InterfaceMethod java/util/Iterator.hasNext:()Z... ... 这是因为集合类所实现的Collection接口继承了Iterable这个接口，因此都能够使用foreach的方式遍历。在ArrayList所实现的iterator方法中，返回的是ArrayList的内部类Itr。在Itr实现的next方法中，会先判断两个值是否相等，改变记录下标cursor和lastRet的值，从0下标开始返回ArrayList内部数组的值。1234567891011121314151617181920212223242526272829303132333435363738394041424344public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125;private class Itr implements Iterator&lt;E&gt; &#123; protected int limit = ArrayList.this.size; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; // modCount是AbstractList的成员变量，表示对List的修改次数 public boolean hasNext() &#123; return cursor &lt; limit; &#125; public E next() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); int i = cursor; if (i &gt;= limit) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; limit--; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125;&#125; ArrayList的删除在next方法中，首先会判断两个表示修改次数的值是否相等，一次来自List的修改，一次来自Iterator的修改，如果不同就抛出ConcurrentModificationException。ArrayList的源码中，remove方法实现如下。传入的对象为空，则清空List，否则删除指定元素，具体如何删除通过fastRemove方法完成。fastRemove会改变modCount的值，然后通过调用arraycopy把index后的所有元素都往前移动，然后List的大小-1。12345678910111213141516171819202122232425public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 真相开始明朗回到例子中，代码 list.remove(bean) 对List进行了一次修改，那么modCount+1，但没有同步到Itr中的expectedModCount。因此，在list.remove(bean)后，iterator调用next()访问下一个元素时，就会导致modCount != expectedModCount，抛出异常。但是，在Itr的remove方法的实现中，每次操作都会把modCount同步到expectedModCount，这样，就不会抛出异常了。因此，正确的遍历删除如下：1234567Iterator&lt;Bean&gt; iterator = list.iterator();while (iterator.hasNext()) &#123; Bean bean = iterator.next(); System.out.println(bean.value); if (bean.value == 2) iterator.remove();&#125; 在输出“4”之前程序结束的情况中，因为List在删除元素后会减小记录自身元素个数的值，也就是size从5变为了4，而此时，遍历访问的下标由3来到了4，也就是访问bean.value = 3的下标向后移了。Itr的hasNext()此时判断，List已经没有元素可以访问了，于是返回了false。 然而这仅仅只是单线程冲突的情况，多线程环境下我们还需要了解其他的集合类。这里只是抛砖引玉，往后会继续分析更多的Java集合类。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]}]}