{"meta":{"title":"Leeleg","subtitle":"来自地球的开发者","description":"正努力着向高质量发展","author":"Leeleg","url":"http://yoursite.com"},"pages":[{"title":"Categories","date":"2017-12-02T10:48:13.000Z","updated":"2018-07-21T08:10:40.625Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-01-28T12:55:31.000Z","updated":"2018-07-21T08:10:35.970Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"一些Java集合类的总结","slug":"一些Java集合类的总结","date":"2018-07-22T03:22:46.000Z","updated":"2018-07-22T03:23:04.688Z","comments":true,"path":"2018/07/22/一些Java集合类的总结/","link":"","permalink":"http://yoursite.com/2018/07/22/一些Java集合类的总结/","excerpt":"","text":"table th:nth-of-type(1) { width: 100px; } 写在开头的话我并不打算一开始就把所有的Java类都拉出来看一遍，毕竟常用的就那么几个，而且它们之间的一些实现原理是相通的，只是根据不同的情况做了改变。因此，我打算从一些基础的Java集合类开始看起，但在此之前先把它们的某些特性了解清楚，如：是否线程安全；内部的数据结构是怎样的。因为知其然，后知所以然，从顶层俯视底层，这样看代码会保有一种清晰的逻辑结构。在这里不会细说实现，只做概括。 主角们 集合 线程安全性 内部数据结构 效率 备注 ArrayList 不安全 数组 访问快，插入、删除慢 LinkedList 不安全 双向循环链表 修改、查找快，插入、删除慢 HashMap 不安全 数组+单链表+红黑树 一般情况下增删改查都是高效率，内部结构变复杂后效率下降 HashMap会根据需要改变内部数据结构 集合 线程安全性 内部数据结构 效率 备注 HashMap 不安全 数组+单链表+红黑树 一般情况下增删改查都是高效率，内部结构变复杂后效率下降 HashMap会根据需要改变内部数据结构","categories":[],"tags":[]},{"title":"从ConcurrentModificationException了解Java集合类的一些实现","slug":"从ConcurrentModificationException了解Java集合类的一些实现","date":"2018-07-21T15:07:25.000Z","updated":"2018-07-21T18:10:21.750Z","comments":true,"path":"2018/07/21/从ConcurrentModificationException了解Java集合类的一些实现/","link":"","permalink":"http://yoursite.com/2018/07/21/从ConcurrentModificationException了解Java集合类的一些实现/","excerpt":"","text":"ConcurrentModificationException的出现ConcurrentModificationException，也就是并发修改异常，当我们使用一些Java集合类时，有时需要遍历集合并根据条件remove其中的元素，此时就有可能出现该异常。我们看个简单的例子，注意 list.remove(bean) 这一行：123456789101112131415161718192021222324252627import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class ConcurrentModifyExceptionDemo &#123; public static void main(String[] args) &#123; List&lt;Bean&gt; list = new ArrayList&lt;&gt;(); list.add(new Bean(0)); list.add(new Bean(1)); list.add(new Bean(2)); list.add(new Bean(3)); list.add(new Bean(4)); for (Bean bean : list) &#123; System.out.println(bean.value); if (bean.value == 2) list.remove(bean); &#125; &#125; static class Bean &#123; int value; public Bean(int value) &#123; this.value = value; &#125; &#125;&#125; 从上面的输出信息我们可以看到，在程序输出“3”之前出现了ConcurrentModificationException，也就是说，该异常是在遍历下一个元素时抛出的。总的来说，删除和遍历产生了冲突。如果改变删除的元素为倒数第二个，就是 bean.value = 3 时：12345for (Bean bean : list) &#123; System.out.println(bean.value); if (bean.value == 3) list.remove(bean);&#125; 程序没有抛出ConcurrentModificationException，但是在打印“4”之前程序就结束了，这是为什么呢？ 从ArrayList内部看异常出现的原因ArrayList的遍历在例子中使用了foreach去遍历元素，实际上，foreach遍历的原理就是使用Iterator进行迭代，可以通过javap进行反编译即可查看到相关的字节码指令（看84行的注释）：12345678910... ...74: invokespecial #5 // Method ConcurrentModifyExceptionDemo$Bean.&quot;&lt;init&gt;&quot;:(I)V77: invokeinterface #6, 2 // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z82: pop83: aload_184: invokeinterface #7, 1 // InterfaceMethod java/util/List.iterator:()Ljava/util/Iterator;89: astore_290: aload_291: invokeinterface #8, 1 // InterfaceMethod java/util/Iterator.hasNext:()Z... ... 这是因为集合类所实现的Collection接口继承了Iterable这个接口，因此都能够使用foreach的方式遍历。在ArrayList所实现的iterator方法中，返回的是ArrayList的内部类Itr。在Itr实现的next方法中，会先判断两个值是否相等，改变记录下标cursor和lastRet的值，从0下标开始返回ArrayList内部数组的值。1234567891011121314151617181920212223242526272829303132333435363738394041424344public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125;private class Itr implements Iterator&lt;E&gt; &#123; protected int limit = ArrayList.this.size; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; // modCount是AbstractList的成员变量，表示对List的修改次数 public boolean hasNext() &#123; return cursor &lt; limit; &#125; public E next() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); int i = cursor; if (i &gt;= limit) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; limit--; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125;&#125; ArrayList的删除在next方法中，首先会判断两个表示修改次数的值是否相等，一次来自List的修改，一次来自Iterator的修改，如果不同就抛出ConcurrentModificationException。ArrayList的源码中，remove方法实现如下。传入的对象为空，则清空List，否则删除指定元素，具体如何删除通过fastRemove方法完成。fastRemove会改变modCount的值，然后通过调用arraycopy把index后的所有元素都往前移动，然后List的大小-1。12345678910111213141516171819202122232425public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 真相开始明朗回到例子中，代码 list.remove(bean) 对List进行了一次修改，那么modCount+1，但没有同步到Itr中的expectedModCount。因此，在list.remove(bean)后，iterator调用next()访问下一个元素时，就会导致modCount != expectedModCount，抛出异常。但是，在Itr的remove方法的实现中，每次操作都会把modCount同步到expectedModCount，这样，就不会抛出异常了。因此，正确的遍历删除如下：1234567Iterator&lt;Bean&gt; iterator = list.iterator();while (iterator.hasNext()) &#123; Bean bean = iterator.next(); System.out.println(bean.value); if (bean.value == 2) iterator.remove();&#125; 在输出“4”之前程序结束的情况中，因为List在删除元素后会减小记录自身元素个数的值，也就是size从5变为了4，而此时，遍历访问的下标由3来到了4，也就是访问bean.value = 3的下标向后移了。Itr的hasNext()此时判断，List已经没有元素可以访问了，于是返回了false。 然而这仅仅只是单线程冲突的情况，多线程环境下我们还需要了解其他的集合类。这里只是抛砖引玉，往后会继续分析更多的Java集合类。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]}]}