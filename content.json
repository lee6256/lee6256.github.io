{"meta":{"title":"Leeleg","subtitle":"来自地球的开发者","description":"正努力着向高质量发展","author":"Leeleg","url":"http://yoursite.com"},"pages":[{"title":"Categories","date":"2017-12-02T10:48:13.000Z","updated":"2018-07-21T08:10:40.625Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-01-28T12:55:31.000Z","updated":"2018-07-21T08:10:35.970Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LinkedList的实现原理","slug":"LinkedList的实现原理","date":"2018-11-10T05:49:49.000Z","updated":"2018-11-10T12:23:02.138Z","comments":true,"path":"2018/11/10/LinkedList的实现原理/","link":"","permalink":"http://yoursite.com/2018/11/10/LinkedList的实现原理/","excerpt":"","text":"LinkedList的初步介绍LinkedList使用了双向循环链表作为其存储的数据结构。由于链表的特点是可以自由的添加新的元素，因此LinkedList不需要初始化大小，且列表伸缩性比ArrayList强(ArrayList只能伸展，不能收缩)。LinkedList在根据一个index查找随机节点时，会判断此index在左半区还是右半区，这样就可以选择是从头节点正向遍历，还是从尾节点反向遍历，要比只从头节点遍历的效率高一些。 接口 List - 列表的实现 Deque - 双端队列的实现 Serializable - 可序列化 123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; ... ... &#125; 内部类 Node - 存储节点，包含三个成员变量： 1234567891011private static class Node&lt;E&gt; &#123; E item; // 节点数据元素 Node&lt;E&gt; next; // 后置节点 Node&lt;E&gt; prev; // 前置节点 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 成员变量 size - 记录元素个数 first - 记录双向链表的头节点 last - 记录双向链表的尾节点 123transient int size = 0;transient Node&lt;E&gt; first;transient Node&lt;E&gt; last; List接口的实现查为了提高查找效率，判断是否从正向还是反向，这样只需遍历一半即可查出节点。 checkElementIndex(int index) - 检查index是否在合法的下标范围内，否则抛异常(0 &lt;= index &lt; size) node(int index) - 查找的主要实现，返回一个Node节点，item为定义的泛型类 123456789101112131415161718public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125;Node&lt;E&gt; node(int index) &#123; if (index &lt; (size &gt;&gt; 1)) &#123; // 判断index在左半区还是右半区，提高查找效率 Node&lt;E&gt; x = first; // 从头节点正向遍历 for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; // 从尾节点反向遍历 for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 增LinkedList节点的插入非常的高效，只需要修改节点的引用指向即可，时间花费主要在查找插入节点的位置，即node方法的消耗。 checkPositionIndex(int index) - 检查index是否在合法的下标范围内，否则抛异常(0 &lt;= index &lt;= size，与get方法的检查范围有差异） linkLast(E e) - 处理插入尾部的节点，插入的主要实现之一 linkBefore(E e, Node\\ succ) - 处理插入中间的节点，插入的主要实现之一 123456789101112131415161718192021222324252627282930313233343536public boolean add(E e) &#123; linkLast(e); return true;&#125;public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) // 插入尾部时 linkLast(element); else linkBefore(element, node(index));&#125;void linkLast(E e) &#123; final Node&lt;E&gt; l = last; // 列表无元素时，last为null final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // 构建节点关系 last = newNode; // 添加的新元素默认作为尾节点 if (l == null) first = newNode; else l.next = newNode; size++; modCount++; // 此变量为父类AbstractList的成员变量，表示对列表的操作数，增、删操作会导致此变量自增&#125;void linkBefore(E e, Node&lt;E&gt; succ) &#123; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) // 因为头节点的前置节点为null first = newNode; else pred.next = newNode; size++; modCount++;&#125; 删通过for循环遍历的方式找到需要删除的节点，再调用unlink方法，把节点的引用置空，然后等待GC。 12345678910111213141516171819202122232425262728293031323334353637383940414243public boolean remove(Object o) &#123; if (o == null) &#123; // 删除节点元素值为null的节点 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125;E unlink(Node&lt;E&gt; x) &#123; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; // 如果是头节点 first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; // 如果是尾节点 last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 改做一次index检查，再调用node方法查找节点 1234567public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125; Deque接口的实现头端进出列、尾端进出列只看最终实现即可，也仅是如何调整节点的引用指向，对链表得心应手的同学大可不必继续观看 linkFirst1234567891011private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) // 是否为头节点 last = newNode; else f.prev = newNode; size++; modCount++;&#125; linkLast与linkBefore参照上方List接口增的实现 unLinkFirst1234567891011121314private E unlinkFirst(Node&lt;E&gt; f) &#123; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element;&#125; unLinkLast1234567891011121314private E unlinkLast(Node&lt;E&gt; l) &#123; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"Android面试(1)","slug":"Android面试-1","date":"2018-10-07T13:07:20.000Z","updated":"2018-10-07T14:08:47.311Z","comments":true,"path":"2018/10/07/Android面试-1/","link":"","permalink":"http://yoursite.com/2018/10/07/Android面试-1/","excerpt":"","text":"ActivityActivity生命周期Activity的4种状态（running/paused/stopped/killed）Android进程优先级（前台/可见/服务/后台/空） 前台进程只有在内存不足以支持前台进程同时继续运行的情况下，系统才会终止这些前台进程进而释放内存。如果一个进程满足以下任一条件，即视为前台进程 ： 用户正在交互的 Activity（已调用 Activity 的 onResume() 方法） 绑定到用户正在交互的 Activity 的 Service 正在“前台”运行的 Service（服务已调用 startForeground()） 正执行 onCreate()、onStart() 或 onDestroy() 的 Service 正执行其 onReceive() 方法的 BroadcastReceiver 可见进程除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。如果一个进程满足以下任一条件，即视为可见进程： 托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况 绑定到可见（或前台）Activity 的 Service 服务进程正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。（例如，在后台播放音乐或从网络下载数据）。除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。 后台进程目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。空进程不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。 手机横竖屏的切换 没有设置Activity的android:configChanges属性时： 设置Activity的android:configChanges属性时： Activity任务栈Activity启动模式standard（默认）singletop（栈顶复用）singletask（栈内复用）singleinstance scheme跳转协议FragmentFragment与Activity的生命周期 FragmentPagerAdapter与FragmentStatePagerAdapter区别FragmentPagerAdapter切换页面时，只是把视图与Activity分离，因此内存并不会被回收。（适用于页面较少的情况）。相反，FragmentStatePagerAdapter切换页面时会直接移除，更节省内存。（适用于页面较多的情况） Fragment通信 Fragment调用Activity的方法getActivity Activity调用Fragment的方法接口回调 Fragment调用Fragment的方法findFragmentById Fragment的replace、add、remove方法Activity中调用replace()方法时的生命周期新替换的Fragment：onAttach &gt; onCreate &gt; onCreateView &gt; onViewCreated &gt; onActivityCreated &gt; onStart &gt; onResume被替换的Fragment：onPause &gt; onStop &gt; onDestroyView &gt; onDestroy &gt; onDetach Activity中调用replace()方法和addToBackStack()方法时的生命周期新替换的Fragment（没有在BackStack中）：onAttach &gt; onCreate &gt; onCreateView &gt; onViewCreated &gt; onActivityCreated &gt; onStart &gt; onResume新替换的Fragment（已经在BackStack中）：onCreateView &gt; onViewCreated &gt; onActivityCreated &gt; onStart &gt; onResume被替换的Fragment：onPause &gt; onStop &gt; onDestroyView Activity中调用show()/hide()方法时的生命周期不会触发任何Fragment的生命周期，只是将该Fragment设置为是否可见。这时此时方法onHiddenChanged派上用场了，当fragment隐藏时，该方法会调用传入参数为true表示该fragment被隐藏了，当fragment调用了show方法后，该方法传入的参数为false，表示该fragment正在显示。 ServiceService的启动方式进程的优先级 前台进程 只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程： 1、正在交互的Activity2、一个绑定到正在交互的Activity的Service3、已调用startForeground()的Service4、正执行生命周期的Service（onCreate、onStart或onDestroy）5、正执行onReceive的BroadcastReceiver 可见进程 除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止可见进程。如果一个进程满足以下任一条件，即视为可见进程： 1、仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity2、绑定到可见（或前台）Activity 的 Service 服务进程 除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。 正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程（例如，在后台播放音乐或从网络下载数据） 后台进程 这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。 包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法） 空进程 保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。 不含任何活动应用组件的进程。","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[]},{"title":"Android面试","slug":"Android面试","date":"2018-09-17T15:51:10.000Z","updated":"2018-09-24T16:56:57.074Z","comments":true,"path":"2018/09/17/Android面试/","link":"","permalink":"http://yoursite.com/2018/09/17/Android面试/","excerpt":"","text":"ActivityActivity生命周期Activity的4种状态（running/paused/stopped/killed）Android进程优先级（前台/可见/服务/后台/空） Activity任务栈Activity启动模式standard（默认）singletop（栈顶复用）singletask（栈内复用）：singleinstance scheme跳转协议FragmentFragment与Activity的生命周期 FragmentPagerAdapter与FragmentStatePagerAdapter区别FragmentPagerAdapter切换页面时，只是把视图与Activity分离，因此内存并不会被回收。（适用于页面较少的情况）。相反，FragmentStatePagerAdapter切换页面时会直接移除，更节省内存。（适用于页面较多的情况） Fragment通信 Fragment调用Activity的方法getActivity Activity调用Fragment的方法接口回调 Fragment调用Fragment的方法findFragmentById Fragment的replace、add、remove方法Activity中调用replace()方法时的生命周期新替换的Fragment：onAttach &gt; onCreate &gt; onCreateView &gt; onViewCreated &gt; onActivityCreated &gt; onStart &gt; onResume被替换的Fragment：onPause &gt; onStop &gt; onDestroyView &gt; onDestroy &gt; onDetach Activity中调用replace()方法和addToBackStack()方法时的生命周期新替换的Fragment（没有在BackStack中）：onAttach &gt; onCreate &gt; onCreateView &gt; onViewCreated &gt; onActivityCreated &gt; onStart &gt; onResume新替换的Fragment（已经在BackStack中）：onCreateView &gt; onViewCreated &gt; onActivityCreated &gt; onStart &gt; onResume被替换的Fragment：onPause &gt; onStop &gt; onDestroyView Activity中调用show()/hide()方法时的生命周期不会触发任何Fragment的生命周期，只是将该Fragment设置为是否可见。这时此时方法onHiddenChanged派上用场了，当fragment隐藏时，该方法会调用传入参数为true表示该fragment被隐藏了，当fragment调用了show方法后，该方法传入的参数为false，表示该fragment正在显示。 ServiceService的启动方式进程的优先级 前台进程 只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程： 1、正在交互的Activity2、一个绑定到正在交互的Activity的Service3、已调用startForeground()的Service4、正执行生命周期的Service（onCreate、onStart或onDestroy）5、正执行onReceive的BroadcastReceiver 可见进程 除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止可见进程。如果一个进程满足以下任一条件，即视为可见进程： 1、仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity2、绑定到可见（或前台）Activity 的 Service 服务进程 除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。 正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程（例如，在后台播放音乐或从网络下载数据） 后台进程 这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。 包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法） 空进程 保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。 不含任何活动应用组件的进程。","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[]},{"title":"ArrayList的实现原理","slug":"ArrayList的实现原理","date":"2018-08-02T14:56:43.000Z","updated":"2018-08-02T15:00:19.307Z","comments":true,"path":"2018/08/02/ArrayList的实现原理/","link":"","permalink":"http://yoursite.com/2018/08/02/ArrayList的实现原理/","excerpt":"","text":"又是写在开篇的话&emsp;&emsp;我们使用集合类往往都是调用它们的增、删、改、查这些方法，所以我想先从这四个方面去了解集合类。当然，我们还得结合一些总结去看代码，去知其所以然。那次，与总结的第一邂逅 开始旅途的第一步&emsp;&emsp;在Android中，为何展示数据的Adapter多数都是使用ArrayList？根据之前总结的特性，ArrayList的随机查找和修改是高效的，删除和插入则相反，这里肯定有猫腻。当然，不能忘记之前的并发冲突的问题。&emsp;&emsp;ArrayList在进行add、remove和clear时，内部一个记录这些修改元素的操作值会发生改变。 成员变量12345private static final int DEFAULT_CAPACITY = 10; // 使用默认构造方法创建数组时的大小private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125; // 标识 elementData 创建时长度为 0private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; // 标识 elementData 使用默认构造方法创建transient Object[] elementData; // 内部数据结构private int size; // 记录元素个数 在remove或add的时候会改变size。注意，数组长度与元素个数不是相等的。 构造方法三个构造方法都比较简单，但要关注elementData是怎么被初始化的。值得注意的是第三个构造方法，以实现了Collection接口的集合类，来初始化elementData，先通过调用toArray转换成数组，再调用Array.copyOf把传进来的集合复制给elementData。1234567891011121314151617181920212223242526// 默认初始化一个空数组public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;// 由参数控制初始化数组的大小public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; // 此处初始化数组 this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; // 创建一个标识为长度是 0 的空数组 this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; // 参数错误，抛出错误 throw new IllegalArgumentException(\"Illegal Capacity: \" + initialCapacity); &#125;&#125;// public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 值得注意的几个方法，都是经常出现的。而第三个方法就是导致ArrayList插入、删除效率低的原因。123456789101112131415161718192021// ArrayList.java 不同的集合有不同的toArray实现public Object[] toArray() &#123; return Arrays.copyOf(elementData, size);&#125;// Arrays.javapublic static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings(\"unchecked\") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125;// System.java // srcPos 和 destPos 都分别表示 src 和 dest 数组想复制的起点，length表示复制的个数public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 增ArrayList是一个可以自动扩容的1234567891011121314151617181920212223242526272829303132333435363738public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // 扩容检查 elementData[size++] = e; // 数组末尾添加元素 return true;&#125;public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125;public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // 扩容检查 System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0;&#125;public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); // 检查是否越界 Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // 扩容检查 int numMoved = size - index; // 原来数组 index 后的元素个数 = 原来的元素个数 - index if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125; 以下为扩充方法。注意，ArrayList扩容是有上限的，数组最大长度为Integer.MAX_VALUE。1234567891011121314151617181920212223private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 是否为默认构造方法创建的空数组 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); // &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 增加数组的操作次数，AbstractList的成员变量 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 默认扩容一半 if (newCapacity - minCapacity &lt; 0) // 扩容后的大小不足以容纳所有的元素，则使用最小的能容纳所有元素的值 newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) // 扩容后超过数组所能容纳的阈值，则使用最小的能容纳所有元素的值 newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; addAll都是使用 System.arraycopy 完成元素添加，而grow方法使用 Arrays.copyOf 完成数组扩容迁移。 删12345678910111213141516171819202122232425262728293031public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 改改和查都是直接通过下标直接访问，时间复杂度为O(1)，所以ArrayList的随机访问是高效率的。1234567891011public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125;E elementData(int index) &#123; return (E) elementData[index];&#125; 查12345public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125; Android为何高频使用ArrayList有了点眉目Android在loading新的数据往往会在List的尾部添加，而ArrayList往尾部添加新数据时不需要成批复制数组；需要与某个Item互动时，随机访问的时间复杂度是O(1)；很多时候，都只是展示数据，或是更改某个Item。如果有比较多删除Item的业务，那么你需要分析自己的功能，对不同的数据结构进行一个权衡，这样，有助于提升APP的性能。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"一些Java集合类的总结","slug":"一些Java集合类的总结","date":"2018-07-22T13:05:31.000Z","updated":"2018-11-10T12:24:13.623Z","comments":true,"path":"2018/07/22/一些Java集合类的总结/","link":"","permalink":"http://yoursite.com/2018/07/22/一些Java集合类的总结/","excerpt":"","text":"写在开头的话我并不打算一开始就把所有的Java类都拉出来看一遍，毕竟常用的就那么几个，而且它们之间的一些实现原理是相通的，只是根据不同的情况做了改变。因此，我打算从一些基础的Java集合类开始看起，但在此之前先把它们的某些特性了解清楚，如：是否线程安全；内部的数据结构是怎样的。因为知其然，后知所以然，从顶层俯视底层，这样看代码会保有一种清晰的逻辑结构。在这里不会细说实现，只做概括。 主角们各自的归属 首先，从接口中知道它们都有什么样的功能，以下是各种接口的简单介绍： List： 定义了List系的数据操作Map： 定义了Map系的数据操作Serializable： 对象可序列化Cloneable： 对象可拷贝，重写clone方法必须实现此接口Collection： 其实这个接口也继承了Iterable接口，可以使用Iterator迭代元素。RandomAccess： 标志该集合类应当使用哪种遍历算法提高效率 table th:nth-of-type(1) { width: 100px; } table th:nth-of-type(2) { width: 90px; } table th:nth-of-type(3) { width: 120px; } 各自的个性 集合 线程安全性 内部数据结构 效率 备注 ArrayList 不安全 数组 访问快，插入、删除慢 - LinkedList 不安全 双向链表 修改、查找慢，插入、删除快 - HashMap 不安全 数组+单链表+红黑树 一般情况下增删改查都是高效率，内部结构变复杂后效率下降 HashMap会根据需要改变内部数据结构 LinkedHashMap 不安全 数组+双向链表 - 可实现LRU算法 HashTable 安全 数组+单链表+红黑树 同HashMap 同HashMap ConcurrentHashMap 安全 数组+双向链表+红黑树 同HashMap 同HashMap CopyOnWriteArrayList 安全 数组 读操作效率高，写操作效率低 会有内存占用和数据一致性问题 从上面的内部数据结构中可以发现一些问题，List系要么只有数组，要么只有链表；而Map都是数组+链表，甚至还有红黑树。其实，Map系是因为要解决相同元素冲突产生碰撞，而采用这种设计，也就是散列表。单向链表和双向链表的区别是，双向链表可以做到顺序存储。红黑树的引入是在JDK8之后添加的，目的是当Map系集合类的元素碰撞过多时，把过长的链表转换为红黑树以提高访问效率。 接下来的就是充满挑战的源码之旅了，希望自己能够坚持下去，然后当作日记去记录下来。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"从ConcurrentModificationException了解Java集合类的一些实现","slug":"从ConcurrentModificationException了解Java集合类的一些实现","date":"2018-07-21T15:07:25.000Z","updated":"2018-07-22T13:10:21.848Z","comments":true,"path":"2018/07/21/从ConcurrentModificationException了解Java集合类的一些实现/","link":"","permalink":"http://yoursite.com/2018/07/21/从ConcurrentModificationException了解Java集合类的一些实现/","excerpt":"","text":"ConcurrentModificationException的出现ConcurrentModificationException，也就是并发修改异常，当我们使用一些Java集合类时，有时需要遍历集合并根据条件remove其中的元素，此时就有可能出现该异常。我们看个简单的例子，注意 list.remove(bean) 这一行：123456789101112131415161718192021222324252627import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class ConcurrentModifyExceptionDemo &#123; public static void main(String[] args) &#123; List&lt;Bean&gt; list = new ArrayList&lt;&gt;(); list.add(new Bean(0)); list.add(new Bean(1)); list.add(new Bean(2)); list.add(new Bean(3)); list.add(new Bean(4)); for (Bean bean : list) &#123; System.out.println(bean.value); if (bean.value == 2) list.remove(bean); &#125; &#125; static class Bean &#123; int value; public Bean(int value) &#123; this.value = value; &#125; &#125;&#125; 从上面的输出信息我们可以看到，在程序输出“3”之前出现了ConcurrentModificationException，也就是说，该异常是在遍历下一个元素时抛出的。总的来说，删除和遍历产生了冲突。如果改变删除的元素为倒数第二个，就是 bean.value = 3 时：12345for (Bean bean : list) &#123; System.out.println(bean.value); if (bean.value == 3) list.remove(bean);&#125; 程序没有抛出ConcurrentModificationException，但是在打印“4”之前程序就结束了，这是为什么呢？ 从ArrayList内部看异常出现的原因ArrayList的遍历在例子中使用了foreach去遍历元素，实际上，foreach遍历的原理就是使用Iterator进行迭代，可以通过javap进行反编译即可查看到相关的字节码指令（看84行的注释）：12345678910... ...74: invokespecial #5 // Method ConcurrentModifyExceptionDemo$Bean.&quot;&lt;init&gt;&quot;:(I)V77: invokeinterface #6, 2 // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z82: pop83: aload_184: invokeinterface #7, 1 // InterfaceMethod java/util/List.iterator:()Ljava/util/Iterator;89: astore_290: aload_291: invokeinterface #8, 1 // InterfaceMethod java/util/Iterator.hasNext:()Z... ... 这是因为集合类所实现的Collection接口继承了Iterable这个接口，因此都能够使用foreach的方式遍历。在ArrayList所实现的iterator方法中，返回的是ArrayList的内部类Itr。在Itr实现的next方法中，会先判断两个值是否相等，改变记录下标cursor和lastRet的值，从0下标开始返回ArrayList内部数组的值。1234567891011121314151617181920212223242526272829303132333435363738394041424344public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125;private class Itr implements Iterator&lt;E&gt; &#123; protected int limit = ArrayList.this.size; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; // modCount是AbstractList的成员变量，表示对List的修改次数 public boolean hasNext() &#123; return cursor &lt; limit; &#125; public E next() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); int i = cursor; if (i &gt;= limit) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; limit--; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125;&#125; ArrayList的删除在next方法中，首先会判断两个表示修改次数的值是否相等，一次来自List的修改，一次来自Iterator的修改，如果不同就抛出ConcurrentModificationException。ArrayList的源码中，remove方法实现如下。传入的对象为空，则清空List，否则删除指定元素，具体如何删除通过fastRemove方法完成。fastRemove会改变modCount的值，然后通过调用arraycopy把index后的所有元素都往前移动，然后List的大小-1。12345678910111213141516171819202122232425public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 真相开始明朗回到例子中，代码 list.remove(bean) 对List进行了一次修改，那么modCount+1，但没有同步到Itr中的expectedModCount。因此，在list.remove(bean)后，iterator调用next()访问下一个元素时，就会导致modCount != expectedModCount，抛出异常。但是，在Itr的remove方法的实现中，每次操作都会把modCount同步到expectedModCount，这样，就不会抛出异常了。因此，正确的遍历删除如下：1234567Iterator&lt;Bean&gt; iterator = list.iterator();while (iterator.hasNext()) &#123; Bean bean = iterator.next(); System.out.println(bean.value); if (bean.value == 2) iterator.remove();&#125; 在输出“4”之前程序结束的情况中，因为List在删除元素后会减小记录自身元素个数的值，也就是size从5变为了4，而此时，遍历访问的下标由3来到了4，也就是访问bean.value = 3的下标向后移了。Itr的hasNext()此时判断，List已经没有元素可以访问了，于是返回了false。 然而这仅仅只是单线程冲突的情况，多线程环境下我们还需要了解其他的集合类。这里只是抛砖引玉，往后会继续分析更多的Java集合类。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]}]}